#include <stdio.h>
#include "esp_sleep.h"
#include "driver/gpio.h"
#include "driver/rtc_io.h"
#include "ulp_lp_core.h"
#include "ulp_main.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"

#include "esp_log.h"
#include "nvs.h"
#include "nvs_flash.h"

#include "display.h"
#include "rfid.h"
#include "json_parser.h"
#include "nvs_config.h"
#include "wifi_time.h"
#include "buzzer.h"
#include "led.h"



#define INTERUPT_PIN 1
#define INTERUPT_PIN_LP 0
#define BUTTON1_PIN_LP 4
#define BUTTON2_PIN_LP 5
#define BUTTON3_PIN_LP 6
#define BUTTON4_PIN_LP 7

#define WAIT_FOR_USER_INPUT_TIMEOUT_MS 20000



static const char* wifi_credentials[2] = {
    "IoTtest",
    "2345678901"
};

uint8_t button_values[4] = {0};

extern const uint8_t ulp_main_bin_start[] asm("_binary_ulp_main_bin_start");
extern const uint8_t ulp_main_bin_end[]   asm("_binary_ulp_main_bin_end");

//log tag
static const char *TAG = "main";
QueueHandle_t interruptQueue;

QueueHandle_t buttonControlQueue; //queue for button control commands
QueueHandle_t chirpQueue; //queue for chirp commands - based on play_chirp function
uint8_t button_control_active = 0; //flag for button - commands will be sent into the queue, only if this flag is set
//DISPLAY MUTEX
SemaphoreHandle_t display_mutex = NULL;

TaskHandle_t wifiTimeSyncTaskHandle = NULL;
uint wifi_fail_counter = 0;
uint wifi_delay_cycles = 0; //delay cycles for wifi connection if previous connection failed - 1 cycle per update task

//queue data type for button control commands - button_id and command, both uint8_t
typedef struct
{
    uint8_t button_id;
    uint8_t command; //1 - short press, 2 - long press
} button_control_t;

u8g2_t u8g2;
u8g2_t *u8g2_ptr = NULL;





static void IRAM_ATTR gpio_isr_handler(void *args)
{
    int pinNumber = (int)args;
    xQueueSendFromISR(interruptQueue, &pinNumber, NULL);
}

void GPIOinteruptTask(void *params)
{
    int pinNumber;
    while (true)
    {
        if (xQueueReceive(interruptQueue, &pinNumber, portMAX_DELAY))
        {
            //check if interupt was generated by the ULP program
            if (pinNumber == INTERUPT_PIN)
            {
                if(ulp_button_pressed_num == 0)
                {
                    ESP_LOGW(TAG, "No button pressed, but interupt received");
                }
                if(ulp_button_pressed_num < 5)
                {   int button = ulp_button_pressed_num;
                    //multiple buttons pressed
                    ESP_LOGI(TAG, "Multiple buttons pressed");
                    //convert button values to uint8_t array from  gpio_values_single_var = (gpio_values_output[0] << 24) | (gpio_values_output[1] << 16) | (gpio_values_output[2] << 8) | gpio_values_output[3];
                    button_values[0] = (ulp_gpio_values_single_var >> 24) & 0xFF;
                    button_values[1] = (ulp_gpio_values_single_var >> 16) & 0xFF;
                    button_values[2] = (ulp_gpio_values_single_var >> 8) & 0xFF;
                    button_values[3] = ulp_gpio_values_single_var & 0xFF;
                    ulp_gpio_values_single_var = 0;
                    if(button_control_active == 1)
                    {
                        button_control_t button_control;
                        button_control.button_id = button-1;
                        button_control.command = button_values[button-1];
                        xQueueSend(buttonControlQueue, &button_control, 0);
                    }
                    if(button_values[button-1] == 1)
                    {
                        ESP_LOGI(TAG, "Button %d pressed", button+1);
                    }
                    else if(button_values[button-1] == 2)
                    {
                        ESP_LOGI(TAG, "Button %d long pressed", button+1);
                    }


                }
                else if(ulp_button_pressed_num == 10)
                {
                    //multiple buttons pressed
                    ESP_LOGI(TAG, "Multiple buttons pressed");
                    //convert button values to uint8_t array from  gpio_values_single_var = (gpio_values_output[0] << 24) | (gpio_values_output[1] << 16) | (gpio_values_output[2] << 8) | gpio_values_output[3];
                    button_values[0] = (ulp_gpio_values_single_var >> 24) & 0xFF;
                    button_values[1] = (ulp_gpio_values_single_var >> 16) & 0xFF;
                    button_values[2] = (ulp_gpio_values_single_var >> 8) & 0xFF;
                    button_values[3] = ulp_gpio_values_single_var & 0xFF;
                    ulp_gpio_values_single_var = 0;
                    for(int i = 0; i < 4; i++)
                    {
                        if(button_values[i] == 1)
                        {
                            ESP_LOGI(TAG, "Button %d pressed", i+1);
                        }
                        else if(button_values[i] == 2)
                        {
                            ESP_LOGI(TAG, "Button %d long pressed", i+1);
                        }
                        if(button_control_active == 1)
                        {
                            button_control_t button_control;
                            button_control.button_id = i;
                            button_control.command = button_values[i];
                            xQueueSend(buttonControlQueue, &button_control, 0);
                        }
                    }

                }

            }
        }
    }
}


static void init_ulp_program(void)
{
    esp_err_t err = ulp_lp_core_load_binary(ulp_main_bin_start, (ulp_main_bin_end - ulp_main_bin_start));
    ESP_ERROR_CHECK(err);

    /* Start the program */
    ulp_lp_core_cfg_t cfg = {
        .wakeup_source = ULP_LP_CORE_WAKEUP_SOURCE_LP_TIMER,
        .lp_timer_sleep_duration_us = 5000,
    };

    err = ulp_lp_core_run(&cfg);
    ESP_ERROR_CHECK(err);
}

void LP_gpio_inicializace(uint8_t gpio_num)
{
    rtc_gpio_init(gpio_num);
    rtc_gpio_set_direction(gpio_num, RTC_GPIO_MODE_INPUT_ONLY);
    rtc_gpio_pulldown_dis(gpio_num);
    rtc_gpio_pullup_en(gpio_num);
}





/**
 * @brief Task created when a PICC is detected.
 *
 * This task retrieves the task associated with the given RFID key from NVS,
 * parses the task JSON into a task_t structure, and displays it. THen it listens for user input.
 *
 * The RFID key is expected to be the key in NVS where the task JSON is stored.
 *
 * @param param Pointer to a string containing the RFID key.
 */
void task_RFID_tag_recieved(void *param)
{
    char *rfid_key = (char *)param;

    int task_id = get_task_id_by_rfid(rfid_key);
    if (task_id < 0)
    {
        ESP_LOGE(TAG, "No task ID found for RFID key");
        vTaskDelete(NULL);
        return;
    }
    char *task_json = retrieve_task_json(task_id);
    free(rfid_key);  // free the copy made in the event handler

    if (task_json != NULL)
    {
        task_t task_buffer;
        if (!parse_task_json(task_json, &task_buffer))
        {
            ESP_LOGE(TAG, "Failed to parse task JSON for RFID key");
        }
        else
        {
            ESP_LOGI(TAG, "RFID task parsed successfully - loading display");
            if (task_buffer.Type == 1)
            {
                //take mutex
                if(xSemaphoreTake(display_mutex, 2000/portTICK_PERIOD_MS)){
                    uint8_t wifi_status = get_wifi_status();
                    uint8_t time_status = get_time_validity();
                    // Assuming wifi_status and time_status as 0 for "OK"
                    if(u8g2_ptr != NULL) {
                        display_task_type1(wifi_status, time_status, &task_buffer, *u8g2_ptr);
                    } else {
                        ESP_LOGE(TAG, "Display is not initialized");
                    }
                    // Wait for user input
                    //clear button queue
                    button_control_t button_control;
                    while (xQueueReceive(buttonControlQueue, &button_control, 0) == pdTRUE)
                    {
                        ESP_LOGI(TAG, "Cleared button control queue");
                    }
                    //set button control active
                    button_control_active = 1;
                    //wait for button press until timeout
                    TickType_t xTicksToWait = pdMS_TO_TICKS(WAIT_FOR_USER_INPUT_TIMEOUT_MS);
                    if (xQueueReceive(buttonControlQueue, &button_control, xTicksToWait) == pdTRUE)
                    {
                        ESP_LOGI(TAG, "Button %d pressed while in task display mode", button_control.button_id);
                        if (button_control.command == 1)
                        {
                            ESP_LOGI(TAG, "Button %d short press while in task display mode", button_control.button_id);
                        }
                        else if (button_control.command == 2)
                        {
                            ESP_LOGI(TAG, "Button %d long pres swhile in task display mode" , button_control.button_id);
                        }
                    }
                    else
                    {
                        ESP_LOGI(TAG, "No button press detected during task display mode == timeout");
                    }
                    //give mutex
                    xSemaphoreGive(display_mutex);
                }
                else
                {
                    ESP_LOGW(TAG, "RFID_TASK-Failed to take display mutex");
                }


            }
            else
            {
                ESP_LOGI(TAG, "Task is not type 1, not displayed");
            }
        }
        free(task_json);
    }
    else
    {
        ESP_LOGE(TAG, "No task JSON retrieved for RFID key");
    }
    vTaskDelete(NULL);
}

void on_RFID_state_changed(void *arg, esp_event_base_t base, int32_t event_id, void *data)
{
    rc522_picc_state_changed_event_t *event = (rc522_picc_state_changed_event_t *)data;
    rc522_picc_t *picc = event->picc;

    if (picc->state == RC522_PICC_STATE_ACTIVE) {
        rc522_picc_print(picc);


        char buffer[RC522_PICC_UID_STR_BUFFER_SIZE_MAX];
        //rc522_picc_uid_to_str(&picc->uid,buffer,sizeof(buffer));
        uid_to_str_no_space(&picc->uid,buffer,sizeof(buffer));
        //ESP_LOGI(TAG, "UID no space = |%s|",buffer);
        if (buffer[0] == '\0')
        {
            ESP_LOGE(TAG, "Failed to convert UID to string");
            return;
        }
        //use buffer as a key for the task directly
        char *rfid_key = strdup(buffer);
        if (rfid_key == NULL)
        {
            ESP_LOGE(TAG, "Failed to allocate memory for RFID key");
            return;
        }
        xTaskCreate(task_RFID_tag_recieved, "task_RFID_tag_recieved", 4096, rfid_key, 1, NULL);



        // v picc->uid.value je pole charu(8 bit uint), kazdy char odpovida 2 hex hodnotam -  extrakce nasledovnce:
        /*
        ESP_LOGI(TAG,"uid:|");
        for (uint32_t i = 0; i < picc->uid.length; i++){
            ESP_LOGI(TAG,"%X",picc->uid.value[i]);
        }
        ESP_LOGI(TAG,"|end of uid\n");
        */
    }
    else if (picc->state == RC522_PICC_STATE_IDLE && event->old_state >= RC522_PICC_STATE_ACTIVE) {
        ESP_LOGI(TAG, "Card has been removed");
    }
}

void task_update_tick(void *params)
{
    uint8_t wifi_status, time_status;
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(1000); // period: 1 second

    while (1)
    {
        // Wait until the next cycle.
        vTaskDelayUntil(&xLastWakeTime, xFrequency);

        // Update the display
        wifi_status = get_wifi_status();
        time_status = get_time_validity();
        if(time_status == 1)
        {
            if (wifiTimeSyncTaskHandle != NULL) {
                eTaskState state = eTaskGetState(wifiTimeSyncTaskHandle);
                if (state != eDeleted) {
                    ESP_LOGD(TAG, "Time sync task is still running. State=%d", state);
                } else {
                    ESP_LOGD(TAG, "Time sync task has been deleted - creating.");
                    if(wifi_status == WIFI_STATUS_DISCONNECTED_FAIL && wifi_delay_cycles < 1)
                    {
                        wifi_delay_cycles = wifi_fail_counter*120;
                        wifi_fail_counter++;
                        xTaskCreate(wifi_sync_sntp_time_once_task, "wifi_sync_sntp_time_once_task", 8000, (void*)wifi_credentials, 1, &wifiTimeSyncTaskHandle);
                        if (wifi_delay_cycles > 90000)
                        {
                            wifi_delay_cycles = 90000;
                        }
                        ESP_LOGW(TAG, "Failed to connect to wifi - retrying in %d seconds", wifi_delay_cycles);

                    }
                    else if(wifi_status == WIFI_STATUS_DISCONNECTED_FAIL)
                    {
                        wifi_delay_cycles--;
                        ESP_LOGW(TAG, "Failed to connect to wifi - retrying in %d seconds", wifi_delay_cycles);

                    }
                    else
                    {
                        wifi_fail_counter = 0;
                        wifi_delay_cycles = 0;
                        xTaskCreate(wifi_sync_sntp_time_once_task, "wifi_sync_sntp_time_once_task", 8000, (void*)wifi_credentials, 1, &wifiTimeSyncTaskHandle);

                    }


                }
            } else {
                ESP_LOGI(TAG, "Time sync task handle is NULL; task not running - creating.");
                xTaskCreate(wifi_sync_sntp_time_once_task, "wifi_sync_sntp_time_once_task", 8000, (void*)wifi_credentials, 1, &wifiTimeSyncTaskHandle);
            }

        }
        //take mutex
       if(xSemaphoreTake(display_mutex, 10/portTICK_PERIOD_MS)){
            if (u8g2_ptr != NULL)
            {
                display_idle_clock_screen(&u8g2, wifi_status, time_status);
            }
            else
            {
                ESP_LOGE(TAG, "Display is not initialized");
            }
            //release mutex
            xSemaphoreGive(display_mutex);
        }
        else
        {
            ESP_LOGW(TAG, "UPDATE_TASK-Failed to take display mutex");
        }
    }
}

void app_main(void)
{
    interruptQueue = xQueueCreate(10, sizeof(int));
    buttonControlQueue = xQueueCreate(10, sizeof(button_control_t));
    display_mutex = xSemaphoreCreateMutex();
    chirpQueue = xQueueCreate(10, sizeof(uint8_t));
    xTaskCreate(play_chirp_task, "play_chirp_task", 2048, (void *)chirpQueue, 2, NULL);
    nvs_flash_init(); //nvs for wifi
    wifi_init();// initializes wifi - does not connect
    esp_err_t err = nvs_flash_init_partition(NVS_PARTITION); //nvs for json data
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "Failed to initialize NVS partition: %s", esp_err_to_name(err));
        return;
    }

    set_default_timetables();
    log_timetable(1);
    log_timetable(2);
    log_timetable(3);

    set_default_tasks();
    log_task(1);
    log_task(2);
    log_task(3);

    rfid_setup(on_RFID_state_changed);

    xTaskCreate(wifi_sync_sntp_time_once_task, "wifi_sync_sntp_time_once_task", 8000, (void*)wifi_credentials, 1, &wifiTimeSyncTaskHandle);

    init_ssd1306_display(&u8g2);
    //xTaskCreate(task_test_SSD1306i2c,"x",4096,NULL,1,NULL);
    u8g2_ptr = &u8g2;

    task_t task_buffer;
    char *task_json = retrieve_task_json(2);
    if (task_json != NULL)
    {
        if (!parse_task_json(task_json, &task_buffer))
        {
            ESP_LOGE(TAG, "Failed to parse task JSON.");
        }
        else
        {
            ESP_LOGI(TAG, "Task parsed successfully.");
        }
        free(task_json);
    }
    else
    {
        ESP_LOGE(TAG, "Failed to retrieve task JSON.");
    }
    display_task_type1(1, 1, &task_buffer, u8g2);



    gpio_set_direction(INTERUPT_PIN, GPIO_MODE_INPUT);
    gpio_pulldown_dis(INTERUPT_PIN);
    gpio_pullup_dis(INTERUPT_PIN);
    gpio_set_intr_type(INTERUPT_PIN, GPIO_INTR_POSEDGE);

    //rtc LP gpio
    rtc_gpio_init(INTERUPT_PIN_LP);
    rtc_gpio_set_direction(INTERUPT_PIN_LP, RTC_GPIO_MODE_OUTPUT_ONLY);
    rtc_gpio_pulldown_dis(INTERUPT_PIN_LP);
    rtc_gpio_pullup_dis(INTERUPT_PIN_LP);

    LP_gpio_inicializace(BUTTON1_PIN_LP);
    LP_gpio_inicializace(BUTTON2_PIN_LP);
    LP_gpio_inicializace(BUTTON3_PIN_LP);
    LP_gpio_inicializace(BUTTON4_PIN_LP);


    init_ulp_program();






    xTaskCreate(GPIOinteruptTask, "GPIOinteruptTask", 2048, NULL, 1, NULL);
    xTaskCreate(task_update_tick, "task_update_tick", 4096, NULL, 1, NULL);

    ESP_ERROR_CHECK(gpio_install_isr_service(0));
    ESP_ERROR_CHECK(gpio_isr_handler_add(INTERUPT_PIN, gpio_isr_handler, (void *)INTERUPT_PIN));

    buzzer_init();
    init_led();
    uint8_t led_value = 255;
    while (1)
    {
        if (led_value > 100)
        {
            //led_value = 100;
        }
        set_led(led_value, led_value, led_value);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        set_led(0, 0, led_value);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        set_led(0, led_value, 0);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        //SEND_CHIRP(chirpQueue, 4);
        set_led(led_value, 0, 0);
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        led_value = led_value-10;
        ESP_LOGI(TAG, "LED value: %d", led_value);
        //log current time
        time_t now;
        struct tm timeinfo;
        time(&now);
        localtime_r(&now, &timeinfo);
        ESP_LOGI(TAG, "Current time: %s", asctime(&timeinfo));


    }

}