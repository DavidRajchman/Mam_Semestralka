#include <stdio.h>
#include "esp_sleep.h"
#include "driver/gpio.h"
#include "driver/rtc_io.h"
#include "ulp_lp_core.h"
#include "ulp_main.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "nvs.h"
#include "nvs_flash.h"

#include "display.h"
#include "rfid.h"
#include "json_parser.h"
#include "nvs_config.h"
#include "wifi_time.h"




#include "led_strip.h"

#define INTERUPT_PIN 1
#define INTERUPT_PIN_LP 0
#define BUTTON1_PIN_LP 4
#define BUTTON2_PIN_LP 5
#define BUTTON3_PIN_LP 6
#define BUTTON4_PIN_LP 7

#define WAIT_FOR_USER_INPUT_TIMEOUT_MS 5000





uint8_t button_values[4] = {0};

extern const uint8_t ulp_main_bin_start[] asm("_binary_ulp_main_bin_start");
extern const uint8_t ulp_main_bin_end[]   asm("_binary_ulp_main_bin_end");

//log tag
static const char *TAG = "main";
QueueHandle_t interruptQueue;

QueueHandle_t buttonControlQueue; //queue for button control commands
uint8_t button_control_active = 0; //flag for button - commands will be sent into the queue, only if this flag is set
//queue data type for button control commands - button_id and command, both uint8_t
typedef struct
{
    uint8_t button_id;
    uint8_t command; //1 - short press, 2 - long press
} button_control_t;

u8g2_t u8g2;
u8g2_t *u8g2_ptr = NULL;




static void IRAM_ATTR gpio_isr_handler(void *args)
{
    int pinNumber = (int)args;
    xQueueSendFromISR(interruptQueue, &pinNumber, NULL);
}

void GPIOinteruptTask(void *params)
{
    int pinNumber;
    while (true)
    {
        if (xQueueReceive(interruptQueue, &pinNumber, portMAX_DELAY))
        {
            //check if interupt was generated by the ULP program
            if (pinNumber == INTERUPT_PIN)
            {
                if(ulp_button_pressed_num == 0)
                {
                    ESP_LOGW(TAG, "No button pressed, but interupt received");
                }
                if(ulp_button_pressed_num < 5)
                {   int button = ulp_button_pressed_num;
                    //multiple buttons pressed
                    ESP_LOGI(TAG, "Multiple buttons pressed");
                    //convert button values to uint8_t array from  gpio_values_single_var = (gpio_values_output[0] << 24) | (gpio_values_output[1] << 16) | (gpio_values_output[2] << 8) | gpio_values_output[3];
                    button_values[0] = (ulp_gpio_values_single_var >> 24) & 0xFF;
                    button_values[1] = (ulp_gpio_values_single_var >> 16) & 0xFF;
                    button_values[2] = (ulp_gpio_values_single_var >> 8) & 0xFF;
                    button_values[3] = ulp_gpio_values_single_var & 0xFF;
                    ulp_gpio_values_single_var = 0;
                    if(button_control_active == 1)
                    {
                        button_control_t button_control;
                        button_control.button_id = button-1;
                        button_control.command = button_values[button-1];
                        xQueueSend(buttonControlQueue, &button_control, 0);
                    }
                    if(button_values[button-1] == 1)
                    {
                        ESP_LOGI(TAG, "Button %d pressed", button+1);
                    }
                    else if(button_values[button-1] == 2)
                    {
                        ESP_LOGI(TAG, "Button %d long pressed", button+1);
                    }


                }
                else if(ulp_button_pressed_num == 10)
                {
                    //multiple buttons pressed
                    ESP_LOGI(TAG, "Multiple buttons pressed");
                    //convert button values to uint8_t array from  gpio_values_single_var = (gpio_values_output[0] << 24) | (gpio_values_output[1] << 16) | (gpio_values_output[2] << 8) | gpio_values_output[3];
                    button_values[0] = (ulp_gpio_values_single_var >> 24) & 0xFF;
                    button_values[1] = (ulp_gpio_values_single_var >> 16) & 0xFF;
                    button_values[2] = (ulp_gpio_values_single_var >> 8) & 0xFF;
                    button_values[3] = ulp_gpio_values_single_var & 0xFF;
                    ulp_gpio_values_single_var = 0;
                    for(int i = 0; i < 4; i++)
                    {
                        if(button_values[i] == 1)
                        {
                            ESP_LOGI(TAG, "Button %d pressed", i+1);
                        }
                        else if(button_values[i] == 2)
                        {
                            ESP_LOGI(TAG, "Button %d long pressed", i+1);
                        }
                        if(button_control_active == 1)
                        {
                            button_control_t button_control;
                            button_control.button_id = i;
                            button_control.command = button_values[i];
                            xQueueSend(buttonControlQueue, &button_control, 0);
                        }
                    }

                }

            }
        }
    }
}


static void init_ulp_program(void)
{
    esp_err_t err = ulp_lp_core_load_binary(ulp_main_bin_start, (ulp_main_bin_end - ulp_main_bin_start));
    ESP_ERROR_CHECK(err);

    /* Start the program */
    ulp_lp_core_cfg_t cfg = {
        .wakeup_source = ULP_LP_CORE_WAKEUP_SOURCE_LP_TIMER,
        .lp_timer_sleep_duration_us = 5000,
    };

    err = ulp_lp_core_run(&cfg);
    ESP_ERROR_CHECK(err);
}

void LP_gpio_inicializace(uint8_t gpio_num)
{
    rtc_gpio_init(gpio_num);
    rtc_gpio_set_direction(gpio_num, RTC_GPIO_MODE_INPUT_ONLY);
    rtc_gpio_pulldown_dis(gpio_num);
    rtc_gpio_pullup_en(gpio_num);
}


void init_led_strip(led_strip_handle_t* led_strip)
{
    /// LED strip common configuration
    led_strip_config_t strip_config = {
        .strip_gpio_num = 8,  // The GPIO that connected to the LED strip's data line
        .max_leds = 1,                 // The number of LEDs in the strip,
        .led_model = LED_MODEL_WS2812, // LED strip model, it determines the bit timing
        .color_component_format = LED_STRIP_COLOR_COMPONENT_FMT_GRB, // The color component format is G-R-B
        .flags = {
            .invert_out = false, // don't invert the output signal
        }
    };

    /// RMT backend specific configuration
    led_strip_rmt_config_t rmt_config = {
        .clk_src = RMT_CLK_SRC_DEFAULT,    // different clock source can lead to different power consumption
        .resolution_hz = 10 * 1000 * 1000, // RMT counter clock frequency: 10MHz
        .mem_block_symbols = 64,           // the memory size of each RMT channel, in words (4 bytes)
        .flags = {
            .with_dma = false, // DMA feature is available on chips like ESP32-S3/P4
        }
    };

    /// Create the LED strip object

    ESP_ERROR_CHECK(led_strip_new_rmt_device(&strip_config, &rmt_config, led_strip));



}


/**
 * @brief Task created when a PICC is detected.
 *
 * This task retrieves the task associated with the given RFID key from NVS,
 * parses the task JSON into a task_t structure, and displays it. THen it listens for user input.
 *
 * The RFID key is expected to be the key in NVS where the task JSON is stored.
 *
 * @param param Pointer to a string containing the RFID key.
 */
void task_RFID_tag_recieved(void *param)
{
    char *rfid_key = (char *)param;

    int task_id = get_task_id_by_rfid(rfid_key);
    if (task_id < 0)
    {
        ESP_LOGE(TAG, "No task ID found for RFID key");
        vTaskDelete(NULL);
        return;
    }
    char *task_json = retrieve_task_json(task_id);
    free(rfid_key);  // free the copy made in the event handler

    if (task_json != NULL)
    {
        task_t task_buffer;
        if (!parse_task_json(task_json, &task_buffer))
        {
            ESP_LOGE(TAG, "Failed to parse task JSON for RFID key");
        }
        else
        {
            ESP_LOGI(TAG, "RFID task parsed successfully - loading display");
            if (task_buffer.Type == 1)
            {
                // Assuming wifi_status and time_status as 0 for "OK"
                if(u8g2_ptr != NULL) {
                    display_task_type1(0, 0, &task_buffer, *u8g2_ptr);
                } else {
                    ESP_LOGE(TAG, "Display is not initialized");
                }
                // Wait for user input
                //clear button queue
                button_control_t button_control;
                while (xQueueReceive(buttonControlQueue, &button_control, 0) == pdTRUE)
                {
                    ESP_LOGI(TAG, "Cleared button control queue");
                }
                //set button control active
                button_control_active = 1;
                //wait for button press until timeout
                TickType_t xTicksToWait = pdMS_TO_TICKS(WAIT_FOR_USER_INPUT_TIMEOUT_MS);
                if (xQueueReceive(buttonControlQueue, &button_control, xTicksToWait) == pdTRUE)
                {
                    ESP_LOGI(TAG, "Button %d pressed while in task display mode", button_control.button_id);
                    if (button_control.command == 1)
                    {
                        ESP_LOGI(TAG, "Button %d short press while in task display mode", button_control.button_id);
                    }
                    else if (button_control.command == 2)
                    {
                        ESP_LOGI(TAG, "Button %d long pres swhile in task display mode" , button_control.button_id);
                    }
                }
                else
                {
                    ESP_LOGI(TAG, "No button press detected during task display mode == timeout");
                }


            }
            else
            {
                ESP_LOGI(TAG, "Task is not type 1, not displayed");
            }
        }
        free(task_json);
    }
    else
    {
        ESP_LOGE(TAG, "No task JSON retrieved for RFID key");
    }
    vTaskDelete(NULL);
}

void on_RFID_state_changed(void *arg, esp_event_base_t base, int32_t event_id, void *data)
{
    rc522_picc_state_changed_event_t *event = (rc522_picc_state_changed_event_t *)data;
    rc522_picc_t *picc = event->picc;

    if (picc->state == RC522_PICC_STATE_ACTIVE) {
        rc522_picc_print(picc);


        char buffer[RC522_PICC_UID_STR_BUFFER_SIZE_MAX];
        //rc522_picc_uid_to_str(&picc->uid,buffer,sizeof(buffer));
        uid_to_str_no_space(&picc->uid,buffer,sizeof(buffer));
        //ESP_LOGI(TAG, "UID no space = |%s|",buffer);
        if (buffer[0] == '\0')
        {
            ESP_LOGE(TAG, "Failed to convert UID to string");
            return;
        }
        //use buffer as a key for the task directly
        char *rfid_key = strdup(buffer);
        if (rfid_key == NULL)
        {
            ESP_LOGE(TAG, "Failed to allocate memory for RFID key");
            return;
        }
        xTaskCreate(task_RFID_tag_recieved, "task_RFID_tag_recieved", 4096, rfid_key, 1, NULL);



        // v picc->uid.value je pole charu(8 bit uint), kazdy char odpovida 2 hex hodnotam -  extrakce nasledovnce:
        /*
        ESP_LOGI(TAG,"uid:|");
        for (uint32_t i = 0; i < picc->uid.length; i++){
            ESP_LOGI(TAG,"%X",picc->uid.value[i]);
        }
        ESP_LOGI(TAG,"|end of uid\n");
        */
    }
    else if (picc->state == RC522_PICC_STATE_IDLE && event->old_state >= RC522_PICC_STATE_ACTIVE) {
        ESP_LOGI(TAG, "Card has been removed");
    }
}


void app_main(void)
{
    esp_err_t err = nvs_flash_init_partition(NVS_PARTITION);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "Failed to initialize NVS partition: %s", esp_err_to_name(err));
        return;
    }
    nvs_flash_init();
    set_default_timetables();
    log_timetable(1);
    log_timetable(2);
    log_timetable(3);

    set_default_tasks();
    log_task(1);
    log_task(2);
    log_task(3);

    rfid_setup(on_RFID_state_changed);

    wifi_init_sta_simple("IoTtest", "2345678901");
    init_sntp();

    init_ssd1306_display(&u8g2);
    //xTaskCreate(task_test_SSD1306i2c,"x",4096,NULL,1,NULL);
    u8g2_ptr = &u8g2;

    task_t task_buffer;
    char *task_json = retrieve_task_json(2);
    if (task_json != NULL)
    {
        if (!parse_task_json(task_json, &task_buffer))
        {
            ESP_LOGE(TAG, "Failed to parse task JSON.");
        }
        else
        {
            ESP_LOGI(TAG, "Task parsed successfully.");
        }
        free(task_json);
    }
    else
    {
        ESP_LOGE(TAG, "Failed to retrieve task JSON.");
    }
    display_task_type1(1, 1, &task_buffer, u8g2);



    gpio_set_direction(INTERUPT_PIN, GPIO_MODE_INPUT);
    gpio_pulldown_dis(INTERUPT_PIN);
    gpio_pullup_dis(INTERUPT_PIN);
    gpio_set_intr_type(INTERUPT_PIN, GPIO_INTR_POSEDGE);

    //rtc LP gpio
    rtc_gpio_init(INTERUPT_PIN_LP);
    rtc_gpio_set_direction(INTERUPT_PIN_LP, RTC_GPIO_MODE_OUTPUT_ONLY);
    rtc_gpio_pulldown_dis(INTERUPT_PIN_LP);
    rtc_gpio_pullup_dis(INTERUPT_PIN_LP);

    LP_gpio_inicializace(BUTTON1_PIN_LP);
    LP_gpio_inicializace(BUTTON2_PIN_LP);
    LP_gpio_inicializace(BUTTON3_PIN_LP);
    LP_gpio_inicializace(BUTTON4_PIN_LP);


    init_ulp_program();

    led_strip_handle_t led_strip;
    init_led_strip(&led_strip);


    interruptQueue = xQueueCreate(10, sizeof(int));
    buttonControlQueue = xQueueCreate(10, sizeof(button_control_t));
    xTaskCreate(GPIOinteruptTask, "GPIOinteruptTask", 2048, NULL, 1, NULL);

    ESP_ERROR_CHECK(gpio_install_isr_service(0));
    ESP_ERROR_CHECK(gpio_isr_handler_add(INTERUPT_PIN, gpio_isr_handler, (void *)INTERUPT_PIN));



    uint8_t led_value = 255;
    while (1)
    {
        if (led_value > 100)
        {
            led_value = 100;
        }
        led_strip_set_pixel(led_strip,0,led_value,0,0);
        led_strip_refresh(led_strip);
        vTaskDelay(500 / portTICK_PERIOD_MS);

        led_strip_set_pixel(led_strip,0,led_value,led_value,led_value);
        led_strip_refresh(led_strip);
        vTaskDelay(500 / portTICK_PERIOD_MS);

        led_strip_set_pixel(led_strip,0,0,led_value,0);
        led_strip_refresh(led_strip);
        vTaskDelay(500 / portTICK_PERIOD_MS);

        led_strip_set_pixel(led_strip,0,0,0,led_value);
        led_strip_refresh(led_strip);
        vTaskDelay(500 / portTICK_PERIOD_MS);
        led_value = led_value-10;
        ESP_LOGI(TAG, "LED value: %d", led_value);
        //log current time
        time_t now;
        struct tm timeinfo;
        time(&now);
        localtime_r(&now, &timeinfo);
        ESP_LOGI(TAG, "Current time: %s", asctime(&timeinfo));
        //if time year is 1970, time is not set //reapeat sntp init
        if(timeinfo.tm_year < 71)
        {
            ESP_LOGE(TAG, "Time not set - reinitializing SNTP");
            init_sntp();
        }

    }

}